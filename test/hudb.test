# Copyright 2022 Tomas Brabec
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

package require tcltest
package require control

namespace import ::tcltest::*

control::control assert enabled 1
namespace import ::control::assert

source [file join [file dirname [info script]] .. hudb hudb.tcl];

#TODO tests to skip as their behavior has not been decided
skip {
    hudb-exists_key.3.3
    hudb-set_key.13.1
    hudb-set_key.13.2
    hudb-set_key.13.3
    hudb-set_key.13.4
}


#------------------------------------------------
# hudb::reset
#------------------------------------------------
test hudb-reset.1 "test of reset empty DB" -setup {
    ::hudb::reset;
} -body {
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


test hudb-reset.2 "test of reset non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::reset;
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


#------------------------------------------------
# hudb::is_empty
#------------------------------------------------
test hudb-is_empty.1 "test of an empty DB" -setup {
    ::hudb::reset;
} -body {
    ::hudb::is_empty;
} -result {1}


test hudb-is_empty.2 "test of a non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::is_empty;
} -result {0}


test hudb-is_empty.3 "test of post reset a non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::reset;
    ::hudb::is_empty;
} -result {1}


#------------------------------------------------
# hudb::set_key
#------------------------------------------------
test hudb-set_key.1.1 "test set (default type, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz}}}}


test hudb-set_key.1.2 "test set (default type, three levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}}


test hudb-set_key.1.3 "test set (default type, one level, multiple keys)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    ::hudb::set_key b 123;
    ::hudb::set_key c true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz} b {s 123} c {s true}}}}


test hudb-set_key.1.4 "test set (default type, multiple levels, multiple keys)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key b 123;
    ::hudb::set_key a/c true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}} c {s true}}} b {s 123}}}}


test hudb-set_key.3.1 "test overwrite (default type, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    ::hudb::set_key a 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s 123}}}}


test hudb-set_key.3.2 "test overwrite (default type, three levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key a/b/c 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {D {c {s 123}}}}}}}}


test hudb-set_key.3.3 "test overwrite (default type, different levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key a 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s 123}}}}


test hudb-set_key.3.4 "test overwrite (different type, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    ::hudb::set_key -type number a 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {num 123}}}}


test hudb-set_key.3.5 "test overwrite (different type, different levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key -type boolean a/b true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {b true}}}}}}


test hudb-set_key.6.1 "test set (string type/single word, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a xyz;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz}}}}


test hudb-set_key.6.2 "test set (string type/multi word, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a "foo bar";
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s {foo bar}}}}}


test hudb-set_key.7.1 "test set (number type/integer, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type number b 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {b {num 123}}}}


test hudb-set_key.7.2 "test set (number type/float, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type number b -1.3;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {b {num -1.3}}}}


test hudb-set_key.8.1 "test set (boolean type/true, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type boolean c true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {c {b true}}}}


test hudb-set_key.8.2 "test set (boolean type/false, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type boolean c false;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {c {b false}}}}


test hudb-set_key.9 "test set (unknown type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type foobar a/b/c xyz;
} -returnCodes {error} -result {Unknown type 'foobar'!}


test hudb-set_key.10.1 "test set (container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type list a/b/c {1 2};
} -returnCodes {error} -result {Container types not supported. Use -json option.}


test hudb-set_key.10.2 "test set (container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type dict a/b/c {1 2};
} -returnCodes {error} -result {Container types not supported. Use -json option.}


test hudb-set_key.11.1 "test set (wrong options: too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.2 "test set (wrong options: too much)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a b c;
} -returnCodes {error} -result {Too many arguments! Args: a b c}


test hudb-set_key.11.3 "test set (wrong options: -type too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.4 "test set (wrong options: -type too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.5 "test set (wrong options: -type too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.6 "test set (wrong options: -type too many)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a b c;
} -returnCodes {error} -result {Too many arguments! Args: -type string a b c}


test hudb-set_key.11.7 "test set (wrong options: -type no type)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type -- a b;
} -returnCodes {error} -result {Missing type for the -type option!}


test hudb-set_key.11.8 "test set (wrong options: unknown option)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -foobar string a c;
} -returnCodes {error} -result {Unknown option '-foobar'!}


test hudb-set_key.12.1 "test set (valid arguments)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string -- a "foo bar";
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s {foo bar}}}}}


#TODO presently undecided, how to treat non-canonical keys
test hudb-set_key.13.1 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key /a xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz}}}}


#TODO presently undecided, how to treat non-canonical keys
test hudb-set_key.13.2 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a//b xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {s xyz}}}}}}


#TODO presently undecided, how to treat an empty key
test hudb-set_key.13.3 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key {} xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


#TODO presently undecided, how to treat the "root" key `/`
test hudb-set_key.13.4 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key / xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


#------------------------------------------------
# hudb::exists_key
#------------------------------------------------
test hudb-exists_key.1.1 "test of an existing key, one level" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a;
} -result {1}


test hudb-exists_key.1.2 "test of an existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a;
} -result {1}


test hudb-exists_key.1.3 "test of an existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b;
} -result {1}


test hudb-exists_key.1.4 "test of an existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b/c;
} -result {1}


test hudb-exists_key.2.1 "test of a non-existing key, one level" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key b;
} -result {0}


test hudb-exists_key.2.2 "test of a non-existing key, one level" -setup {
    set ::hudb::db {HUDDLE {D {a {s b}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b;
} -result {0}


test hudb-exists_key.2.3 "test of a non-existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b/c/xyz;
} -result {0}


test hudb-exists_key.2.4 "test of a non-existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/c;
} -result {0}


test hudb-exists_key.2.5 "test of a non-existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key /b/c;
} -result {0}


test hudb-exists_key.3.1 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key a;
} -result {0}


test hudb-exists_key.3.2 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key;
} -returnCodes {error} -result {Too few arguments: ''}


#TODO Presently it is unknown, how to treat an empty key.
test hudb-exists_key.3.3 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key {};
} -result {0}


#TODO Presently it is unknown, how to treat a "root" key `/`.
test hudb-exists_key.3.4 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key /;
} -result {0}


test hudb-exists_key.4.1 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a b c;
} -result {1}


test hudb-exists_key.4.2 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key c b;
} -result {1}


test hudb-exists_key.4.3 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key c a a b c;
} -result {1}


test hudb-exists_key.4.4 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key  a d c;
} -result {0}


test hudb-exists_key.4.5 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key  a c a d;
} -result {0}


test hudb-exists_key.4.6 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key  a a/a a;
} -result {0}


#------------------------------------------------
# hudb::get_key
#------------------------------------------------
test hudb-get_key.1.1 "test of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key c;
} -result {false}


test hudb-get_key.1.2 "test of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key b/c;
} -result {123}


test hudb-get_key.1.3 "test of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a/b/c;
} -result {xyz}


test hudb-get_key.1.4 "test of an existing key, list value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key d;
} -result {foo bar}


test hudb-get_key.1.5 "test of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key b;
} -result {c 123}


test hudb-get_key.1.6 "test of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a;
} -result {b {c xyz}}


test hudb-get_key.1.7 "test of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a/b;
} -result {c xyz}


test hudb-get_key.2.1 "test of type of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type c;
} -result {boolean}


test hudb-get_key.2.2 "test of tyoe of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type b/c;
} -result {number}


test hudb-get_key.2.3 "test of type of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a/b/c;
} -result {string}


test hudb-get_key.2.4 "test of type of an existing key, list value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type d;
} -result {list}


test hudb-get_key.2.5 "test of type of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type b;
} -result {dict}


test hudb-get_key.2.6 "test of type of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a;
} -result {dict}


test hudb-get_key.2.7 "test of type of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a/b;
} -result {dict}


test hudb-get_key.3.1 "test of raw representation of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw c;
} -result {HUDDLE {b false}}


test hudb-get_key.3.2 "test of raw representation of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw b/c;
} -result {HUDDLE {num 123}}


test hudb-get_key.3.3 "test of raw representation of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a/b/c;
} -result {HUDDLE {s xyz}}


test hudb-get_key.3.4 "test of raw representation of an existing key, list value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw d;
} -result {HUDDLE {L {{s foo} {s bar}}}}


test hudb-get_key.3.5 "test of raw representation of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw b;
} -result {HUDDLE {D {c {num 123}}}}


test hudb-get_key.3.6 "test of raw representation of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a;
} -result {HUDDLE {D {b {D {c {s xyz}}}}}}


test hudb-get_key.3.7 "test of raw representation of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a/b;
} -result {HUDDLE {D {c {s xyz}}}}


#------------------------------------------------
# hudb::is_wellformed
#------------------------------------------------
test hudb-is_wellformed.1 "test of an empty DB" -setup {
    ::hudb::reset;
} -body {
    ::hudb::is_wellformed;
} -result {1}


test hudb-is_wellformed.2 "test of a non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::is_wellformed;
} -result {1}


#------------------------------------------------
# custom type: uri
#------------------------------------------------
test hudb-uri.1.1 "test of URI `set_key -type uri`" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type uri a /my/absolute/path;
} -result {HUDDLE {D {a {uri /my/absolute/path}}}}


test hudb-uri.2.1 "test of URI `get_key`" -setup {
    set ::hudb::db {HUDDLE {D {a {uri /my/absolute/path}}}} 
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a;
} -result {/my/absolute/path}


test hudb-uri.2.2 "test of URI `get_key -type`" -setup {
    set ::hudb::db {HUDDLE {D {a {uri /my/absolute/path}}}} 
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a;
} -result {uri}


test hudb-uri.2.3 "test of URI `get_key -raw`" -setup {
    set ::hudb::db {HUDDLE {D {a {uri /my/absolute/path}}}} 
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a;
} -result {HUDDLE {uri /my/absolute/path}}


#------------------------------------------------
# filepath: rebase
#------------------------------------------------
test hudb-filepath_rebase.1.1.1 "test of path rebase (abs paths)" -body {
    ::hudb::filepath::rebase /a/b /e/f/g
} -result {../../e/f/g}

test hudb-filepath_rebase.1.1.2 "test of path rebase (abs paths)" -body {
    ::hudb::filepath::rebase /a/b/ /e/f/g
} -result {../../e/f/g}

test hudb-filepath_rebase.1.2.1 "test of path rebase (abs paths, same dir)" -body {
    ::hudb::filepath::rebase /e/f /e/f/g
} -result {g}

test hudb-filepath_rebase.1.2.2 "test of path rebase (abs paths, same dir)" -body {
    ::hudb::filepath::rebase /e/f/ /e/f/g
} -result {g}

test hudb-filepath_rebase.1.3 "test of path rebase (abs paths, same path)" -body {
    ::hudb::filepath::rebase /e/f/g /e/f/g
} -result {.}

test hudb-filepath_rebase.1.4 "test of path rebase (abs path to root base)" -body {
    ::hudb::filepath::rebase / /e/f/g
} -result {e/f/g}

#TODO test other combinations of relative and absolute paths


#------------------------------------------------
# to_file
#------------------------------------------------

# writing to stdout
test hudb-to_file.2.1 "test writing file in huddle format (stdout)" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::to_file -huddle
} -cleanup {
    ::hudb::reset
} -result {} -output {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}}

# writing to a file
test hudb-to_file.2.2 "test writing file in huddle format (file)" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
    set path [file join [file dirname [info script]] hudb-to_file.2.2];
} -body {
    ::hudb::to_file -huddle ${path};
    puts -nonewline stdout [read [open ${path}]];
} -cleanup {
    ::hudb::reset;
    file delete ${path};
    unset path;
} -result {} -output {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}}

# writing to stdout
test hudb-to_file.3.1 "test writing file in json format" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::to_file -json
} -cleanup {
    ::hudb::reset
} -result {} -output {{"a":{"b":{"c":"xyz"}},"b":{"c":123},"c":false}}

# writing to a file
test hudb-to_file.3.2 "test writing file in json format (file)" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
    set path [file join [file dirname [info script]] hudb-to_file.3.2];
} -body {
    ::hudb::to_file -json ${path};
    puts -nonewline stdout [read [open ${path}]];
} -cleanup {
    ::hudb::reset;
    file delete ${path};
    unset path;
} -result {} -output {{"a":{"b":{"c":"xyz"}},"b":{"c":123},"c":false}}


#------------------------------------------------
# end of unit tests
#------------------------------------------------

tcltest::cleanupTests

