# Copyright 2022 Tomas Brabec
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

package require tcltest
namespace import ::tcltest::*

# import the `control` package
if {[catch {package require control}]} {
    # `control` not available so make a custom substitute
    # (code origin: https://wiki.tcl-lang.org/page/Assertions)
    proc assert {condition} {
        if {![uplevel 1 expr $condition]} {
            return -code error "assertion failed: $condition"
        }
    }
} else {
    control::control assert enabled 1;
    namespace import ::control::assert;
}

source [file join [file dirname [info script]] .. hudb hudb.tcl];

#TODO tests to skip as their behavior has not been decided
skip {
    hudb-exists_key.3.3
    hudb-set_key.13.1
    hudb-set_key.13.2
    hudb-set_key.13.3
    hudb-set_key.13.4
}


#------------------------------------------------
# hudb::_get_db_ref
#------------------------------------------------
test hudb-_get_db_ref.1 "test of getting a fully qulified name of internal DB obejct" -body {
    ::hudb::_get_db_ref;
} -result {::hudb::db}


#------------------------------------------------
# hudb::_reset
#------------------------------------------------
test hudb-_reset.1 "test of resetting a local DB object" -setup {
    set ::hudb::db {foo bar};
    set db {hello world};
} -body {
    set result 0;
    ::hudb::_reset db;

    # test local variable
    set exp {HUDDLE {D {}}};
    if {$db ne $exp} {
        incr result $i;
        error "Unexpected local DB:\n\tact=$db\n\texp=$exp";
    }

    # test internal DB variable
    set exp {foo bar};
    if {$::hudb::db ne $exp} {
        incr result $i;
        error "Unexpected internal DB:\n\tact=$db\n\texp=$exp";
    }

    return $result;
} -cleanup {
    unset db exp;
} -result {0}


test hudb-_reset.2 "test of resetting a hudb internal DB object" -setup {
    set ::hudb::db {foo bar};
    set db {hello world};
} -body {
    set result 0;
    ::hudb::_reset [::hudb::_get_db_ref];

    # test local variable
    set exp {hello world};
    if {$db ne $exp} {
        incr result $i;
        error "Unexpected local DB:\n\tact=$db\n\texp=$exp";
    }

    # test internal DB variable
    set exp {HUDDLE {D {}}};
    if {$::hudb::db ne $exp} {
        incr result $i;
        error "Unexpected internal DB:\n\tact=$db\n\texp=$exp";
    }

    return $result;
} -cleanup {
    unset db exp;
} -result {0}


#------------------------------------------------
# hudb::reset
#------------------------------------------------
test hudb-reset.1 "test of reset empty DB" -setup {
    ::hudb::reset;
} -body {
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


test hudb-reset.2 "test of reset non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::reset;
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


#------------------------------------------------
# hudb::is_empty
#------------------------------------------------
test hudb-is_empty.1 "test of an empty DB" -setup {
    ::hudb::reset;
} -body {
    ::hudb::is_empty;
} -result {1}


test hudb-is_empty.2 "test of a non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::is_empty;
} -result {0}


test hudb-is_empty.3 "test of post reset a non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::reset;
    ::hudb::is_empty;
} -result {1}


#------------------------------------------------
# hudb::set_key
#------------------------------------------------
test hudb-set_key.1.1 "test set (default type, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz}}}}


test hudb-set_key.1.2 "test set (default type, three levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}}


test hudb-set_key.1.3 "test set (default type, one level, multiple keys)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    ::hudb::set_key b 123;
    ::hudb::set_key c true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz} b {s 123} c {s true}}}}


test hudb-set_key.1.4 "test set (default type, multiple levels, multiple keys)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key b 123;
    ::hudb::set_key a/c true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}} c {s true}}} b {s 123}}}}


test hudb-set_key.3.1 "test overwrite (default type, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    ::hudb::set_key a 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s 123}}}}


test hudb-set_key.3.2 "test overwrite (default type, three levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key a/b/c 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {D {c {s 123}}}}}}}}


test hudb-set_key.3.3 "test overwrite (default type, different levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key a 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s 123}}}}


test hudb-set_key.3.4 "test overwrite (different type, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a xyz;
    ::hudb::set_key -type number a 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {num 123}}}}


test hudb-set_key.3.5 "test overwrite (different type, different levels)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a/b/c xyz;
    ::hudb::set_key -type boolean a/b true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {b true}}}}}}


test hudb-set_key.6.1 "test set (string type/single word, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a xyz;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz}}}}


test hudb-set_key.6.2 "test set (string type/multi word, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a "foo bar";
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s {foo bar}}}}}


test hudb-set_key.7.1 "test set (number type/integer, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type number b 123;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {b {num 123}}}}


test hudb-set_key.7.2 "test set (number type/float, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type number b -1.3;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {b {num -1.3}}}}


test hudb-set_key.8.1 "test set (boolean type/true, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type boolean c true;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {c {b true}}}}


test hudb-set_key.8.2 "test set (boolean type/false, one level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type boolean c false;
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {c {b false}}}}


test hudb-set_key.9 "test set (unknown type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type foobar a/b/c xyz;
} -returnCodes {error} -result {Invalid type: 'foobar'}


test hudb-set_key.10.1.1 "test set (container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type list a/b/c {1 2};
} -result {HUDDLE {D {a {D {b {D {c {L {{s 1} {s 2}}}}}}}}}}


test hudb-set_key.10.1.2 "test set (container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type {list number} a/b/c {1 2};
} -result {HUDDLE {D {a {D {b {D {c {L {{num 1} {num 2}}}}}}}}}}


test hudb-set_key.10.2.1 "test set (container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type dict a/b/c {1 2};
} -result {HUDDLE {D {a {D {b {D {c {D {1 {s 2}}}}}}}}}}


test hudb-set_key.10.2.2 "test set (container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type {dict * number} a/b/c {1 2};
} -result {HUDDLE {D {a {D {b {D {c {D {1 {num 2}}}}}}}}}}


test hudb-set_key.10.3.1 "test set (complex container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type {dict * list} a/b/c {1 2 3 4};
} -result {HUDDLE {D {a {D {b {D {c {D {1 {L {{s 2}}} 3 {L {{s 4}}}}}}}}}}}}


test hudb-set_key.10.3.2 "test set (complex container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type {dict * {list number}} a/b/c {1 2 3 4};
} -result {HUDDLE {D {a {D {b {D {c {D {1 {L {{num 2}}} 3 {L {{num 4}}}}}}}}}}}}


test hudb-set_key.10.3.3 "test set (complex container type, multi level)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type {dict * list} a/b/c {1 {2 3 4}};
} -result {HUDDLE {D {a {D {b {D {c {D {1 {L {{s 2} {s 3} {s 4}}}}}}}}}}}}


test hudb-set_key.11.1 "test set (wrong options: too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.2 "test set (wrong options: too much)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a b c;
} -returnCodes {error} -result {Too many arguments! Args: a b c}


test hudb-set_key.11.3 "test set (wrong options: -type too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.4 "test set (wrong options: -type too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.5 "test set (wrong options: -type too few)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a;
} -returnCodes {error} -result {Wrong number of arguments}


test hudb-set_key.11.6 "test set (wrong options: -type too many)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string a b c;
} -returnCodes {error} -result {Too many arguments! Args: -type string a b c}


test hudb-set_key.11.7 "test set (wrong options: -type no type)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type -- a b;
} -returnCodes {error} -result {Missing type for the -type option!}


test hudb-set_key.11.8 "test set (wrong options: unknown option)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -foobar string a c;
} -returnCodes {error} -result {Unknown option '-foobar'!}


test hudb-set_key.12.1 "test set (valid arguments)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type string -- a "foo bar";
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s {foo bar}}}}}


#TODO presently undecided, how to treat non-canonical keys
test hudb-set_key.13.1 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key /a xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {s xyz}}}}


#TODO presently undecided, how to treat non-canonical keys
test hudb-set_key.13.2 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key a//b xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {a {D {b {s xyz}}}}}}


#TODO presently undecided, how to treat an empty key
test hudb-set_key.13.3 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key {} xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


#TODO presently undecided, how to treat the "root" key `/`
test hudb-set_key.13.4 "test set (weird key)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key / xyz;
#TODO    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {}}}


test hudb-set_key.14.1.1 "test set -raw (boolean)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -raw x/y/z {b false};
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {x {D {y {D {z {b false}}}}}}}}


test hudb-set_key.14.1.2 "test set -raw (string)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -raw x {s {my string}};
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {x {s {my string}}}}}


test hudb-set_key.14.1.3 "test set -raw (number)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -raw x/0 {num 1.21};
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {x {D {0 {num 1.21}}}}}}


test hudb-set_key.14.1.4 "test set -raw (list)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -raw x {L {{s a} {s b} {s c}}};
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {x {L {{s a} {s b} {s c}}}}}}


test hudb-set_key.14.1.5 "test set -raw (dict)" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -raw x {D {0 {num 1.21}}};
    assert {![::hudb::is_empty]}
    set db $::hudb::db;
} -result {HUDDLE {D {x {D {0 {num 1.21}}}}}}


#------------------------------------------------
# hudb::exists_key
#------------------------------------------------
test hudb-exists_key.1.1 "test of an existing key, one level" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a;
} -result {1}


test hudb-exists_key.1.2 "test of an existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a;
} -result {1}


test hudb-exists_key.1.3 "test of an existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b;
} -result {1}


test hudb-exists_key.1.4 "test of an existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b/c;
} -result {1}


test hudb-exists_key.2.1 "test of a non-existing key, one level" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key b;
} -result {0}


test hudb-exists_key.2.2 "test of a non-existing key, one level" -setup {
    set ::hudb::db {HUDDLE {D {a {s b}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b;
} -result {0}


test hudb-exists_key.2.3 "test of a non-existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/b/c/xyz;
} -result {0}


test hudb-exists_key.2.4 "test of a non-existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a/c;
} -result {0}


test hudb-exists_key.2.5 "test of a non-existing key, multi level" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key /b/c;
} -result {0}


test hudb-exists_key.3.1 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key a;
} -result {0}


test hudb-exists_key.3.2 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key;
} -returnCodes {error} -result {Too few arguments: ''}


#TODO Presently it is unknown, how to treat an empty key.
test hudb-exists_key.3.3 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key {};
} -result {0}


#TODO Presently it is unknown, how to treat a "root" key `/`.
test hudb-exists_key.3.4 "test of a non-existing key, empty DB" -setup {
    ::hudb::reset
} -body {
    ::hudb::exists_key /;
} -result {0}


test hudb-exists_key.4.1 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key a b c;
} -result {1}


test hudb-exists_key.4.2 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key c b;
} -result {1}


test hudb-exists_key.4.3 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key c a a b c;
} -result {1}


test hudb-exists_key.4.4 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key  a d c;
} -result {0}


test hudb-exists_key.4.5 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key  a c a d;
} -result {0}


test hudb-exists_key.4.6 "test of existing keys" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz} b {num 123} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::exists_key  a a/a a;
} -result {0}


#------------------------------------------------
# hudb::get_key
#------------------------------------------------
test hudb-get_key.1.1 "test of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key c;
} -result {false}


test hudb-get_key.1.2 "test of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key b/c;
} -result {123}


test hudb-get_key.1.3 "test of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a/b/c;
} -result {xyz}


test hudb-get_key.1.4 "test of an existing key, list value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key d;
} -result {foo bar}


test hudb-get_key.1.5 "test of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key b;
} -result {c 123}


test hudb-get_key.1.6 "test of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a;
} -result {b {c xyz}}


test hudb-get_key.1.7 "test of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a/b;
} -result {c xyz}


test hudb-get_key.2.1 "test of type of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type c;
} -result {boolean}


test hudb-get_key.2.2 "test of tyoe of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type b/c;
} -result {number}


test hudb-get_key.2.3 "test of type of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a/b/c;
} -result {string}


test hudb-get_key.2.4 "test of type of an existing key, list value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type d;
} -result {list}


test hudb-get_key.2.5 "test of type of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type b;
} -result {dict}


test hudb-get_key.2.6 "test of type of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a;
} -result {dict}


test hudb-get_key.2.7 "test of type of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a/b;
} -result {dict}


test hudb-get_key.3.1 "test of raw representation of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw c;
} -result {HUDDLE {b false}}


test hudb-get_key.3.2 "test of raw representation of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw b/c;
} -result {HUDDLE {num 123}}


test hudb-get_key.3.3 "test of raw representation of an existing key, scalar value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a/b/c;
} -result {HUDDLE {s xyz}}


test hudb-get_key.3.4 "test of raw representation of an existing key, list value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw d;
} -result {HUDDLE {L {{s foo} {s bar}}}}


test hudb-get_key.3.5 "test of raw representation of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw b;
} -result {HUDDLE {D {c {num 123}}}}


test hudb-get_key.3.6 "test of raw representation of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a;
} -result {HUDDLE {D {b {D {c {s xyz}}}}}}


test hudb-get_key.3.7 "test of raw representation of an existing key, dict value" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false} d {L {{s foo} {s bar}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a/b;
} -result {HUDDLE {D {c {s xyz}}}}


#------------------------------------------------
# hudb::is_wellformed
#------------------------------------------------
test hudb-is_wellformed.1 "test of an empty DB" -setup {
    ::hudb::reset;
} -body {
    ::hudb::is_wellformed;
} -result {1}


test hudb-is_wellformed.2 "test of a non-empty DB" -setup {
    set ::hudb::db {HUDDLE {D {a {s xyz}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::is_wellformed;
} -result {1}


#------------------------------------------------
# custom type: uri
#------------------------------------------------
test hudb-uri.1.1 "test of URI `set_key -type uri`" -setup {
    ::hudb::reset;
} -body {
    ::hudb::set_key -type uri a /my/absolute/path;
} -result {HUDDLE {D {a {uri /my/absolute/path}}}}


test hudb-uri.2.1 "test of URI `get_key`" -setup {
    set ::hudb::db {HUDDLE {D {a {uri /my/absolute/path}}}} 
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key a;
} -result {/my/absolute/path}


test hudb-uri.2.2 "test of URI `get_key -type`" -setup {
    set ::hudb::db {HUDDLE {D {a {uri /my/absolute/path}}}} 
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -type a;
} -result {uri}


test hudb-uri.2.3 "test of URI `get_key -raw`" -setup {
    set ::hudb::db {HUDDLE {D {a {uri /my/absolute/path}}}} 
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::get_key -raw a;
} -result {HUDDLE {uri /my/absolute/path}}


#------------------------------------------------
# filepath: rebase
#------------------------------------------------
test hudb-filepath_rebase.1.1.1 "test of path rebase (abs paths)" -body {
    ::hudb::filepath::rebase /a/b /e/f/g
} -result {../../e/f/g}

test hudb-filepath_rebase.1.1.2 "test of path rebase (abs paths)" -body {
    ::hudb::filepath::rebase /a/b/ /e/f/g
} -result {../../e/f/g}

test hudb-filepath_rebase.1.2.1 "test of path rebase (abs paths, same dir)" -body {
    ::hudb::filepath::rebase /e/f /e/f/g
} -result {g}

test hudb-filepath_rebase.1.2.2 "test of path rebase (abs paths, same dir)" -body {
    ::hudb::filepath::rebase /e/f/ /e/f/g
} -result {g}

test hudb-filepath_rebase.1.3 "test of path rebase (abs paths, same path)" -body {
    ::hudb::filepath::rebase /e/f/g /e/f/g
} -result {.}

test hudb-filepath_rebase.1.4 "test of path rebase (abs path to root base)" -body {
    ::hudb::filepath::rebase / /e/f/g
} -result {e/f/g}

test hudb-filepath_rebase.2.1.1 "test of path rebase (abs tgt, rel path)" -body {
    ::hudb::filepath::rebase /a/b e/f /c/d
} -result {../../c/d/e/f}

test hudb-filepath_rebase.2.1.2 "test of path rebase (abs tgt, rel path)" -body {
    ::hudb::filepath::rebase /a/b ./e/f /c/d/.
} -result {../../c/d/e/f}

test hudb-filepath_rebase.2.2.1 "test of path rebase, same dir (abs tgt, rel path)" -body {
    ::hudb::filepath::rebase /a/b e/f /a/b
} -result {e/f}

test hudb-filepath_rebase.2.2.2 "test of path rebase, same dir (abs tgt, rel path)" -body {
    ::hudb::filepath::rebase /a/b e/f /a/./b/c/..
} -result {e/f}

test hudb-filepath_rebase.3.1.1 "test of path rebase (rel tgt, rel path, default src)" -body {
    ::hudb::filepath::rebase a/b e/f
} -result {../../e/f}

test hudb-filepath_rebase.3.1.2 "test of path rebase (rel tgt, rel path, default src)" -body {
    ::hudb::filepath::rebase ./a//b/ ../e/f
} -result {../../../e/f}

test hudb-filepath_rebase.3.2.1 "test of path rebase, same dir (rel tgt, rel path, default src)" -body {
    ::hudb::filepath::rebase a/b a//b/./e/f
} -result {e/f}

test hudb-filepath_rebase.3.2.2 "test of path rebase, same dir (rel tgt, rel path, default src)" -body {
    ::hudb::filepath::rebase ../a/b ./../a/b/e/f
} -result {e/f}

test hudb-filepath_rebase.3.3.1 "test of path rebase (rel tgt, rel path, abs src)" -body {
    ::hudb::filepath::rebase a/b e/f [file normalize [pwd]]
} -result {../../e/f}

test hudb-filepath_rebase.3.3.2 "test of path rebase (rel tgt, rel path, abs src)" -body {
    ::hudb::filepath::rebase ./a//b/ ../e/f [file normalize [pwd]]
} -result {../../../e/f}

test hudb-filepath_rebase.3.4.1 "test of path rebase, same dir (rel tgt, rel path, abs src)" -body {
    ::hudb::filepath::rebase a/b a//b/./e/f [file normalize [pwd]]
} -result {e/f}

test hudb-filepath_rebase.3.4.2 "test of path rebase, same dir (rel tgt, rel path, abs src)" -body {
    ::hudb::filepath::rebase ../a/b ./../a/b/e/f [file normalize [pwd]]
} -result {e/f}

test hudb-filepath_rebase.3.5.1 "test of path rebase, same dir (rel tgt, rel path, rel src)" -body {
    ::hudb::filepath::rebase a/b e/f a/b
} -result {e/f}

test hudb-filepath_rebase.3.5.2 "test of path rebase, same dir (rel tgt, rel path, rel src)" -body {
    ::hudb::filepath::rebase ../a/b ./e/f c/../../a/b/.
} -result {e/f}

test hudb-filepath_rebase.3.5.3 "test of path rebase, same dir (rel tgt, rel path, rel src)" -body {
    ::hudb::filepath::rebase a/b a/b/e/f a/b
} -result {a/b/e/f}

test hudb-filepath_rebase.3.6.1 "test of path rebase (abs tgt, rel path, default src)" -body {
    ::hudb::filepath::rebase [file join [file normalize [pwd]] a/b] e/f
} -result {../../e/f}

test hudb-filepath_rebase.3.6.2 "test of path rebase (abs tgt, rel path, default src)" -body {
    ::hudb::filepath::rebase [file join [file normalize [pwd]] a/b] ../e/f
} -result {../../../e/f}

test hudb-filepath_rebase.3.7.1 "test of path rebase (abs tgt, rel path, abs src)" -body {
    ::hudb::filepath::rebase [file join [file normalize [pwd]] a/b] e/f [file join [file normalize [pwd]] c/d]
} -result {../../c/d/e/f}

test hudb-filepath_rebase.3.8.1 "test of path rebase (abs tgt, abs path, abs src)" -body {
    ::hudb::filepath::rebase [file join [file normalize [pwd]] a/b] \
        [file join [file normalize [pwd]] e/f] [file join [file normalize [pwd]] c/d]
} -result {../../e/f}


#------------------------------------------------
# to_file
#------------------------------------------------

# writing to stdout
test hudb-to_file.2.1 "test writing file in huddle format (stdout)" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::to_file -huddle
} -cleanup {
    ::hudb::reset
} -result {} -output {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}}

# writing to a file
test hudb-to_file.2.2 "test writing file in huddle format (file)" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
    set path [file join [file dirname [info script]] hudb-to_file.2.2];
} -body {
    ::hudb::to_file -huddle ${path};
    puts -nonewline stdout [read [open ${path}]];
} -cleanup {
    ::hudb::reset;
    file delete ${path};
    unset path;
} -result {} -output {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}}

# writing to stdout incl. rebasing relative file paths
test hudb-to_file.2.3 "test writing file in huddle format and rebasing URIs (stdout)" -setup {
    set ::hudb::db {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri a/b/c} c {uri ../a/b/c}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }

    # change to a new PWD
    set cwd_bak [file normalize [pwd]]; cd "/";
} -body {
    ::hudb::to_file -huddle
} -cleanup {
    # change back to original PWD
    cd ${cwd_bak};
    unset cwd_bak;
    ::hudb::reset
} -result {} -output {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri a/b/c} c {uri ../a/b/c}}}}}}

# writing to a file incl. rebasing relative file paths
test hudb-to_file.2.4 "test writing file in huddle format and rebasing URIs (file)" -setup {
    set ::hudb::db {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri a/b/c} c {uri ../a/b/c}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
    set path [file join [file normalize [file dirname [info script]]] hudb-to_file.2.4];
    file mkdir ${path};

    # change to a new PWD
    set cwd_bak [file normalize [pwd]];
    cd [file dirname ${path}];
} -body {
    ::hudb::to_file -huddle [file join ${path} output_db];
    puts -nonewline stdout [read [open [file join ${path} output_db]]];
} -cleanup {
    ::hudb::reset;
    # change back to original PWD
    cd ${cwd_bak};
    file delete [file join ${path} output_db];
    file delete ${path}
    unset path cwd_bak;
} -result {} -output {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri ../a/b/c} c {uri ../../a/b/c}}}}}}

# writing to stdout
test hudb-to_file.3.1 "test writing file in json format" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
} -body {
    ::hudb::to_file -json
} -cleanup {
    ::hudb::reset
} -result {} -output {{"a":{"b":{"c":"xyz"}},"b":{"c":123},"c":false}}

# writing to a file
test hudb-to_file.3.2 "test writing file in json format (file)" -setup {
    set ::hudb::db {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
    set path [file join [file dirname [info script]] hudb-to_file.3.2];
} -body {
    ::hudb::to_file -json ${path};
    puts -nonewline stdout [read [open ${path}]];
} -cleanup {
    ::hudb::reset;
    file delete ${path};
    unset path;
} -result {} -output {{"a":{"b":{"c":"xyz"}},"b":{"c":123},"c":false}}

# writing to stdout incl. rebasing relative file paths
test hudb-to_file.3.3 "test writing file in JSON format and rebasing URIs (stdout)" -setup {
    set ::hudb::db {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri a/b/c} c {uri ../a/b/c}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }

    # change to a new PWD
    set cwd_bak [file normalize [pwd]]; cd "/";
} -body {
    ::hudb::to_file -json
} -cleanup {
    # change back to original PWD
    cd ${cwd_bak};
    unset cwd_bak;
    ::hudb::reset
} -result {} -output {{"paths":{"a":"/a/b/c","b":"a/b/c","c":"../a/b/c"}}}

# writing to a file incl. rebasing relative file paths
test hudb-to_file.3.4 "test writing file in JSON format and rebasing URIs (file)" -setup {
    set ::hudb::db {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri a/b/c} c {uri ../a/b/c}}}}}};
    if {![::hudb::huddle::isHuddle $::hudb::db]} {
        error "Malformed DB!";
    }
    set path [file join [file normalize [file dirname [info script]]] hudb-to_file.3.4];
    file mkdir ${path};

    # change to a new PWD
    set cwd_bak [file normalize [pwd]];
    cd [file dirname ${path}];
} -body {
    ::hudb::to_file -json [file join ${path} output_db];
    puts -nonewline stdout [read [open [file join ${path} output_db]]];
} -cleanup {
    ::hudb::reset;
    # change back to original PWD
    cd ${cwd_bak};
    file delete [file join ${path} output_db];
    file delete ${path}
    unset path cwd_bak;
} -result {} -output {{"paths":{"a":"/a/b/c","b":"../a/b/c","c":"../../a/b/c"}}}


#------------------------------------------------
# from_files
#------------------------------------------------

# reading into the default DB
test hudb-from_files.2.1.1 "test reading a single file in huddle format" -setup {
    set path [file join [file dirname [info script]] hudb-from_files-2.1.1];
    set fl [open $path w];
    puts -nonewline $fl {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {D {d {b false}}}}}};
    close $fl;
    ::hudb::reset;
} -body {
    ::hudb::from_files -huddle $path;
    return ${::hudb::db};
} -cleanup {
    ::hudb::reset;
    file delete $path;
    unset fl path;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {D {d {b false}}}}}}

# reading into the default DB (ignoring non-dict 1st-level items)
test hudb-from_files.2.1.2 "test reading a single file in huddle format (ignore non-dict 1st level items)" -setup {
    set path [file join [file dirname [info script]] hudb-from_files-2.1.2];
    set fl [open $path w];
    puts -nonewline $fl {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {b false}}}};
    close $fl;
    ::hudb::reset;
} -body {
    ::hudb::from_files -huddle $path;
    return ${::hudb::db};
} -cleanup {
    ::hudb::reset;
    file delete $path;
    unset fl path;
} -result {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}}}}}

# reading into a custom DB
test hudb-from_files.2.2.1 "test reading a single file in huddle format" -setup {
    set exp {HUDDLE {D {a {D {b {D {c {s xyz}}}}} b {D {c {num 123}}} c {D {d {b false}}}}}};
    set path [file join [file dirname [info script]] hudb-from_files-2.2.1];
    set fl [open $path w];
    puts -nonewline $fl $exp;
    close $fl;
    ::hudb::reset;
    set db {HUDDLE {D {}}};
} -body {
    set result 0;
    ::hudb::from_files -db db -huddle $path;
    if {${db} ne ${exp}} {
        error "Custom DB not as expected!\n\tact=${db}\n\texp=${exp}";
        incr result 1;
    }
    if {![::hudb::is_empty]} {
        error "Default DB not empty!";
        incr result 1;
    }
    return $result;
} -cleanup {
    ::hudb::reset;
    file delete $path;
    unset fl path db exp;
} -result {0}

# reading multiple files (default DB)
test hudb-from_files.3.1 "test reading a multiple files in huddle format" -setup {
    set basepath [file join [file dirname [info script]] hudb-from_files-3.1];
    set paths {};
    set inputs {
        A {HUDDLE {D {a {D {b {D {c {s A}}}}} b {D {x {num 1}}} A {D {d {s A}}}}}}
        B {HUDDLE {D {a {D {c {s B}}} b {D {x {num 2}}} B {D {d {s B}}}}}}
        C {HUDDLE {D {a {D {b {D {d {s C}}} d {s C}}} b {D {x {num 3}}} C {D {d {s C}}}}}}
    };
    foreach k [dict keys ${inputs}] {
        set path "${basepath}${k}";
        set fl [open ${path} w];
        puts -nonewline $fl [dict get ${inputs} ${k}];
        close $fl;
        lappend paths ${path};
        unset fl path;
    }
    unset inputs basepath;
    ::hudb::reset;
} -body {
    eval ::hudb::from_files -huddle ${paths};
    return ${::hudb::db};
} -cleanup {
    ::hudb::reset;
    foreach path ${paths} {
        file delete $path;
    }
    unset -nocomplain path paths;
} -result {HUDDLE {D {a {D {b {D {d {s C}}} c {s B} d {s C}}} b {D {x {num 3}}} A {D {d {s A}}} B {D {d {s B}}} C {D {d {s C}}}}}}

# reading a single file with path rebase (default DB)
test hudb-from_files.4.1 "test rebasing on reading a single file in huddle format" -setup {
    set path [file join [file dirname [file normalize [info script]]] hudb-from_files-4.1];
    file mkdir ${path};

    # change to a new PWD
    set cwd_bak [file normalize [pwd]];
    cd [file dirname ${path}];

    set fl [open [file join $path input_db] w];
    puts -nonewline $fl {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri a/b/c} c {uri ../a/b/c}}}}}};
    close $fl;

    ::hudb::reset;
} -body {
    ::hudb::from_files -huddle [file join $path input_db];
    return ${::hudb::db};
} -cleanup {
    ::hudb::reset;
    # change back to original PWD
    cd ${cwd_bak};
    file delete [file join $path input_db];
    file delete $path;
    unset fl path cwd_bak;
} -result  {HUDDLE {D {paths {D {a {uri /a/b/c} b {uri hudb-from_files-4.1/a/b/c} c {uri a/b/c}}}}}};


#------------------------------------------------
# huddle::uri
#------------------------------------------------

# create
# ------
test huddle-uri-create.1.1 "test of creating huddle::uri (abs path)" -body {
    ::hudb::huddle uri /a/b/c;
} -result {HUDDLE {uri /a/b/c}}

test huddle-uri-create.1.2 "test of creating huddle::uri (rel path)" -body {
    ::hudb::huddle uri a/b/c;
} -result {HUDDLE {uri a/b/c}}

test huddle-uri-create.1.3 "test of creating huddle::uri (rel path)" -body {
    ::hudb::huddle uri a/.//b/../c/;
} -result {HUDDLE {uri a/.//b/../c/}}

# equal
# -----
test huddle-uri-equal.1 "test of comparing huddle::uri (same obj)" -body {
    set a [::hudb::huddle uri /a/b/c];
    ::hudb::huddle::equal $a $a;
} -result {1}

test huddle-uri-equal.2 "test of comparing huddle::uri (exact same path)" -body {
    set a [::hudb::huddle uri /a/b/c];
    set b [::hudb::huddle uri /a/b/c];
    ::hudb::huddle::equal $a $b;
} -result {1}

test huddle-uri-equal.3 "test of comparing huddle::uri (different path)" -body {
    set a [::hudb::huddle uri /a/b/c];
    set b [::hudb::huddle uri /x/y/z];
    ::hudb::huddle::equal $a $b;
} -result {0}

test huddle-uri-equal.4.1 "test of comparing huddle::uri (same rel path)" -body {
    set a [::hudb::huddle uri a/b/c];
    set b [::hudb::huddle uri a/b/c];
    ::hudb::huddle::equal $a $b;
} -result {1}

test huddle-uri-equal.4.2 "test of comparing huddle::uri (same rel path)" -body {
    set a [::hudb::huddle uri a/b/c];
    set b [::hudb::huddle uri ./a/b/c];
    ::hudb::huddle::equal $a $b;
} -result {1}

test huddle-uri-equal.4.3 "test of comparing huddle::uri (same rel path)" -body {
    set a [::hudb::huddle uri [file join [pwd] a b c]];
    set b [::hudb::huddle uri a/b/c];
    ::hudb::huddle::equal $a $b;
} -result {1}

test huddle-uri-equal.5.1 "test of comparing huddle::uri (same rel and abs path)" -body {
    set a [::hudb::huddle uri [file normalize a/b/c]];
    set b [::hudb::huddle uri a/b/c];
    ::hudb::huddle::equal $a $b;
} -result {1}

# jsondump
# --------
test huddle-uri-jsondump.1.1 "test of jsondump huddle::uri (abs path)" -body {
    set h [::hudb::huddle uri /a/b/c];
    ::hudb::huddle::jsondump $h "" "";
} -result {"/a/b/c"}

test huddle-uri-jsondump.1.2 "test of jsondump huddle::uri (abs path)" -body {
    set h [::hudb::huddle uri a/b//../c/.];
    ::hudb::huddle::jsondump $h "" "";
} -result {"a/b//../c/."}

test huddle-uri-jsondump.2.1 "test of jsondump huddle::uri (rel path)" -body {
    set h [::hudb::huddle uri a/b/c];
    ::hudb::huddle::jsondump $h "" "";
} -result {"a/b/c"}

test huddle-uri-jsondump.2.2 "test of jsondump huddle::uri (rel path)" -body {
    set h [::hudb::huddle uri ../a/b/c/..];
    ::hudb::huddle::jsondump $h "" "";
} -result {"../a/b/c/.."}


#------------------------------------------------
# end of unit tests
#------------------------------------------------

tcltest::cleanupTests

